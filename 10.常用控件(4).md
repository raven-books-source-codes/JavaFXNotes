# WebView

Javafxwebview (JavaFX.scene.web. Webview)组件能够在 JavaFX 应用程序中显示网页(HTML、 CSS、 SVG、 JavaScript)。 因此，javafxwebview 是一个迷你浏览器。 当您需要显示文档(例如帮助文本)、新闻、博客文章或其他需要在运行时从 web 服务器下载的内容时，WebView 组件非常方便。

Javafxwebview 内部使用 **WebKit** 开源浏览器引擎渲染网页。

## JavaFX WebView Example

Webview 组件是一个 JavaFX 节点，因此它可以像其他 JavaFX 组件一样包含在场景图中，后者也是一个 Node。 下面是一个简单的 JavaFX WebView 示例:

```
public class WebViewExample extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    public void start(Stage primaryStage) {
        primaryStage.setTitle("JavaFX WebView Example");

        WebView webView = new WebView();

        webView.getEngine().load("http://google.com");

        VBox vBox = new VBox(webView);
        Scene scene = new Scene(vBox, 960, 600);

        primaryStage.setScene(scene);
        primaryStage.show();

    }
}
```

这个例子展示了一个 JavaFX 应用程序，它创建了一个 WebView，这个 WebView 被插入到一个 JavaFX VBox 布局组件中，这个组件又被放在一个 JavaFX Stage 中，这个 Stage 设置在主 Stage 中。

![image-20200504155119774](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504155119774.png)

## WebView WebEngine

Javafxwebview WebEngine (JavaFX.scene.web. Webengine)是 WebView 用来加载要在 WebView 中显示的数据的内部组件。 要使 WebView WebEngine 加载数据，您必须首先从 WebView 获得 WebEngine 实例。

### Obtaining the WebEngine

您可以通过调用 WebView getEngine ()方法从 WebView 获得 WebEngine。 下面是从 JavaFX WebView 获取 WebEngine 的一个例子:

```
WebView webView = new WebView();

WebEngine webEngine = webView.getEngine();
```

### Load a Web Page

```
webEngine.load("https://www.baidu.com");
```

### Load Local Content

Webviewwebengine 可以加载在方法调用中直接提供给它的本地内容(而不是通过 Internet 加载)。 Webengine 通过 loadContent ()方法加载本地内容。 下面是使用 loadContent ()在 javafxwebview 中加载本地包含的示例

```
String content =
    "Hello World!";

webEngine.loadContent(content, "text/html");
```

上面示例中 loadContent ()调用的第一个参数是内容本身。 在这个示例中，它是一个包含在 Java String 中的非常简单的 HTML 文档。

上面示例中 loadContent ()调用的第二个参数是内容的内容类型(mime type)。 因为我们要加载一个 HTML 文档，所以它的标准内容类型是 text / HTML。

### Reload Content

```
webEngine.reload();
```

## WebView Zoom

可以设置 javafxwebview 的缩放级别。 例如，您可以指定 WebView 应该始终放大25% ，或缩小10% 等。 放大缩放 WebView 中显示的所有内容。 通过 setZoom ()方法设置 WebView 缩放级别。 下面是一个设置 JavaFX WebView 缩放级别的例子:

```java
webView.setZoom(1.25);  //zoom in 25%.
```

## WebView Font Scale

还可以只缩放 javafxwebview 中显示的文本，而不缩放 WebView 中显示的任何非文本内容(例如图像)。 通过 setFontScale ()方法设置字体缩放属性。 下面是一个将 JavaFX WebView 中显示的文本放大25% (总共125%)的例子:

```java
webView.setFontScale(1.25);
```

## Set User-Agent HTTP Header

您可以设置发送到您的 WebView 实例正在从中加载网页的 web 服务器的 User-Agent HTTP 头。 通过 WebEngine setUserAgent ()方法设置 User-Agent HTTP 头。 下面是一个设置 WebView 的 User-Agent HTTP 头的示例:

```
webEngine.setUserAgent("MyApp Web Browser 1.0");
```

您不需要设置 User-Agent HTTP Header，但是您可能对将您的特定应用程序显示为单独的浏览器感兴趣。 您可能希望包含应用程序正在使用的 WebKit 版本。 这使得网络服务器有更好的机会为他们的访问者浏览器优化他们的网站，包括你的。 下面是一个在 User-Agent 中包含 JavaFX 和 WebKit 版本的例子:

```
webEngine.setUserAgent("MyApp Web Browser 1.0 - AppleWebKit/555.99 JavaFX 8.0");
```

## Disable WebView Context Menu

Javafxwebview 有一个默认的上下文菜单(右键单击菜单) ，当您在 JavaFX 应用程序中的 WebView 上右键单击(上下文单击)时会显示该菜单。 通过调用参数值为 false 的 WebView setContextMenuEnabled ()方法，可以禁用 WebView 上下文菜单。 下面是一个禁用 JavaFX WebView 上下文菜单的例子:

```java
webView.setContextMenuEnabled(false);
```

## Browsing History

您可以访问 javafxwebview 的浏览历史。 浏览历史包括用户在 WebView 中浏览时访问过的页面。 您可以通过其 WebEngine 对象访问 javafxwebview 的浏览历史记录。 调用 WebEngine getistory ()方法，就会得到一个 WebHistory 对象。 下面是一个从 WebView WebEngine 对象获取 WebHistory 对象的例子:

```
WebEngine webEngine = webView.getEngine();
WebHistory history = webEngine.getHistory();
```

### Browsing History Entries

```
ObservableList<WebHistory.Entry> entries = history.getEntries();
```

### Iterate Browsing History Entries

```java
Iterator<WebHistory.Entry> iterator = entries.iterator();
while(iterator.hasNext()){
    WebHistory.Entry entry = iterator.next();
}
```

### WebHistory.Entry

A `WebHistory.Entry` contains the following information:

- URL 网址
- Title 标题
- Last visited date 最后访问日期

您可以使用以下方法从 WebHistory 中访问 URL、标题和上次访问的日期:

```
String url           = entry.getUrl();
String title         = entry.getTitle();
Date lastVisitedDate = entry.getLastVisitedDate();
```

### Go Forward and Backward in History

```
history.go(-1);		// 后退
history.go( 1);		// 前进
```

### Current History Entry Index

如果您在浏览历史记录中来回移动了一点，您可能会有兴趣查看当前历史记录条目在浏览历史记录中的索引。 可以通过 WebHistory getCurrentIndex ()方法查看当前浏览历史记录条目的索引。 下面是一个阅读当前浏览历史记录条目索引的例子:

```
int currentIndex = history.getCurrentIndex();
```

## Listening for State Changes When Loading Document

当您告诉 WebEngine 加载文档时，文档将通过另一个线程在后台加载。 您可以侦听文档加载状态中的更改，因此可以在文档完成加载时收到通知。 下面是一个监听 WebView WebEngine 的文档加载状态变化的例子:

```java
webEngine.getLoadWorker().stateProperty().addListener(
    new ChangeListener() {
        @Override
        public void changed(ObservableValue observable, Object oldValue, Object newValue) {
            System.out.println("oldValue: " + oldValue);
            System.out.println("newValue: " + newValue);

            if (newValue == Worker.State.SUCCEEDED) {
                //document finished loading
            }
        }
    }
);
```

## Execute JavaScript From Java

It is possible to execute JavaScript embedded in the HTML page displayed inside a JavaFX `WebView` from Java. You execute JavaScript in a `WebView` from Java via the `WebEngine` `executeScript()` method. Here is a simple example of executing JavaScript embedded in a `WebView` from Java code:

```
webEngine.executeScript("myFunction()");
```

Executescript ()方法接受 Java String 作为参数，该参数包含要执行的 JavaScript。 上面的示例调用一个名为 myFunction ()的 JavaScript 函数。 这个函数必须定义在网页内部显示在 WebView 的上面的 WebEngine 中。

作者说这个方法目前还有点问题，只能在 WebEngine 监听器中执行才有效果。也就是:

```java
webEngine.getLoadWorker().stateProperty().addListener(
    new ChangeListener() {
        @Override
        public void changed(ObservableValue observable, Object oldValue, Object newValue) {
            System.out.println("oldValue: " + oldValue);
            System.out.println("newValue: " + newValue);

            if (newValue != Worker.State.SUCCEEDED) {
                return;
            }
            System.out.println("Succeeded!");
            String hello = (String) webEngine.executeScript("myFunction()");
            System.out.println("hello: " + hello);
        }
    }
);
```

### JavaScript Return Values

```
String returnValue = (String) webEngine.executeScript("myFunction()");
```

The following table shows what Java types various JavaScript return types are converted to:

| JavaScript Type | Java Type                                 |
| :-------------- | :---------------------------------------- |
| null            | null                                      |
| boolean         | Boolean                                   |
| int32           | Integer                                   |
| number          | Double                                    |
| string          | String                                    |
| object          | JSObject (`netscape.javascript.JSObject`) |

## Executing Java From JavaScript

也可以从运行在 javafxwebview 中的 JavaScript 调用 Java 代码。 为了做到这一点，您必须使 Java 对象对运行在 WebView 中的 JavaScript 可用。 最简单的方法是将 Java 对象设置为 WebView 中显示的文档中的窗口对象的成员。 以下是如何做到这一点:

```
webEngine.getLoadWorker().stateProperty().addListener(
    new ChangeListener() {
        @Override
        public void changed(ObservableValue observable, Object oldValue, Object newValue) {
            if (newValue != Worker.State.SUCCEEDED) { return; }

            JSObject window = (JSObject) webEngine.executeScript("window");
            window.setMember("myObject", new MyObject());
        }
    }
);
```

上面的示例首先通过 WebEngine executeScript ()方法获得对窗口对象的访问。 其次，该示例将 MyObject 类的实例设置为窗口对象上的成员。 运行在 WebView 中的 JavaScript 现在可以调用这个对象上的方法，就像它是一个 JavaScript 对象一样。

```java
public static class MyObject {

    public void doIt() {
        System.out.println("doIt() called");
    }
}
```

一旦这个类的一个对象被公开为window对象 myObject 的成员，你可以像这样调用它的 doIt ()方法:

```
window.myObject.doIt();
```

请记住，当文档首次在 WebView 中加载时，窗口对象上还没有公开 myObject。 因此，如果您尝试立即调用它上面的方法，它可能会失败。

## Access the DOM

通过调用 WebEngine getDocument ()方法，可以访问 javafxwebview 中显示的网页的 DOM。 下面是一个访问 WebView 的 DOM 的例子:

```
Document document = webEngine.getDocument();
```

The `Document` object returned is a `org.w3c.dom.Document` instance.

## Web Page CSS Style Sheet

通常一个网页会提供它自己的 CSS 样式表。 但是，如果网页没有 CSS 样式表，可以使用 WebEngine setUserStyleSheetLocation ()为其设置 CSS 样式表。 下面是一个使用 WebEngine setUserStyleSheetLocation ()为网页设置 CSS 样式表的示例;

```
webEngine.setUserStyleSheetLocation("stylesheet.css");
```

作为参数传递给 setUserStyleSheetLocation ()方法的 String 应该是文件系统中到 CSS 样式表文件所在位置的路径,

It is possible to style a JavaFX `WebView` component with CSS, just like you can style any other JavaFX component. You can set the following CSS properties for a JavaFX `WebView`:

| CSS Property               | Description                                                  |
| :------------------------- | :----------------------------------------------------------- |
| `-fx-context-menu-enabled` | Accepts the value of `true` or `false` - which specifies whether or not the context menu (right click menu) is enabled or not. |
| `-fx-font-smoothing-type`  | Specifies the kind of font smoothing to apply.               |
| `-fx-font-scale`           | A decimal number (e.g. `1.4`) setting the font scale of this `WebView` |

# PieChart

The JavaFX PieChart component is capable of drawing pie charts in your JavaFX application based on data you supply it. The PieChart component is really easy to use. The JavaFX PieChart component is represented by the class `javafx.scene.chart.PieChart` .

## 例子

```java
public class PieChartExperiments extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle("My First JavaFX App");

        PieChart pieChart = new PieChart();

        PieChart.Data slice1 = new PieChart.Data("Desktop", 213);
        PieChart.Data slice2 = new PieChart.Data("Phone"  , 67);
        PieChart.Data slice3 = new PieChart.Data("Tablet" , 36);

        pieChart.getData().add(slice1);
        pieChart.getData().add(slice2);
        pieChart.getData().add(slice3);

        VBox vbox = new VBox(pieChart);

        Scene scene = new Scene(vbox, 400, 200);

        primaryStage.setScene(scene);
        primaryStage.setHeight(300);
        primaryStage.setWidth(1200);

        primaryStage.show();
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}
```

![image-20200504161006609](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504161006609.png)

# TableView

The JavaFX *TableView* enables you to display table views inside your JavaFX applications. The JavaFX TableView is represented by the class `javafx.scene.control.TableView` .

## Classes Related to TableView

The JavaFX TableView class uses a set of related classes to do its job. These classes are:

- TableColumn
- TableRow
- TableCell
- TablePosition
- TableViewFocusModel
- TableViewSelectionModel

## JavaFX TableView Example

```java
@Override
public void start(Stage primaryStage) {

  TableView tableView = new TableView();

  TableColumn<String, Person> column1 = new TableColumn<>("First Name");
  column1.setCellValueFactory(new PropertyValueFactory<>("firstName"));


  TableColumn<String, Person> column2 = new TableColumn<>("Last Name");
  column2.setCellValueFactory(new PropertyValueFactory<>("lastName"));


  tableView.getColumns().add(column1);
  tableView.getColumns().add(column2);

  tableView.getItems().add(new Person("John", "Doe"));
  tableView.getItems().add(new Person("Jane", "Deer"));

  VBox vbox = new VBox(tableView);

  Scene scene = new Scene(vbox);

  primaryStage.setScene(scene);

  primaryStage.show();
}
```

## Add TableColumn to the TableView

创建了 TableView 之后，您需要向 TableView 实例添加一个或多个 TableColumn 实例。 Tablecolumn 表示一个垂直的值列。 每个值都显示在自己的行上，通常从 TableView 中显示的对象列表中提取。 下面是向 javafxtableview 实例添加两个 TableColumn 实例的示例:

```java
TableView tableView = new TableView();

TableColumn<String, Person> firstNameColumn = TableColumn<>("First Name");
firstNameColumn.setCellValueFactory(new PropertyValueFactory<>("firstName"));

TableColumn<String, Person> lastNameColumn = new TableColumn<>("Last Name");
lastNameColumn.setCellValueFactory(new PropertyValueFactory<>("lastName"));
```

注意传递给 TableColumn 类的构造函数的 Java String 参数。 此字符串将显示为该列上方的列标题。 您可以在本页顶部的屏幕快照中看到这样一个列标题的示例。

Tablecolumn 必须在其上设置单元格值 factory。 单元格值工厂提取要在列中的每个单元格(每行)中显示的值。 在上面的示例中，使用了 PropertyValueFactory。 Propertyvaluefactory 工厂可以从 Java 对象中提取属性值(字段值)。 属性的名称作为参数传递给 PropertyValueFactory 构造函数，如下所示:

```
PropertyValueFactory factory = new PropertyValueFactory<>("firstName");
```

The property name `firstName` will match the getter getter method `getFirstName()` of the `Person` objects which contain the values are displayed on each row.

## Add Data to TableView

在 javafxtableview 中添加了 TableColumn 实例之后，可以将要显示的数据添加到 TableView 中。 数据通常包含在一个常规 Java 对象(pojo)列表中。 下面是向 TableView 添加两个 Person 对象(本 javafxtableview 教程前面显示的类)的示例:

```java
tableView.getItems().add(new Person("John", "Doe"));
tableView.getItems().add(new Person("Jane", "Deer"));
```

## Set Placeholder When No Rows to Display

可以设置一个占位符，以便在 javafxtableview 没有要显示的行时显示。 占位符必须是 javafxnode 类的实例，JavaFX 的大多数(如果不是全部)控件都是 javafxnode 类的实例。 因此，您可以使用 javafximageview 或 javafxlabel 作为占位符。 下面是一个在 JavaFX TableView 中使用 Label 作为占位符的例子:

```java
tableView.setPlaceholder(new Label("No rows to display"));
```

![image-20200504161721209](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504161721209.png)

## TableView Selection Model

The JavaFX TableView component has an internal *SelectionModel* which is used to either read what rows and / or cells the user has selected, or to select rows and cells programmatically. In the following sections I will take a closer look at the JavaFX TableView SelectionModel.

### Obtain TableView SelectionModel Instance

To obtain the JavaFX TableView `SelectionModel` you must call its `getSelectionModel()` method. Here is an example of obtaining the `SelectionModel` from a JavaFX TableView:

```java
TableViewSelectionModel selectionModel = tableView.getSelectionModel();
```

The TableViewSelectionModel class can have a generic type set on it. Typically that type will be the same as was used for the data displayed in the TableView. Here is an example of declaring a generic type on the TableViewSelectionModel when obtaining it:

```java
TableViewSelectionModel<Person> selectionModel = tableView.getSelectionModel();
```

You can set the *selection mode* of the TableView TableViewSelectionModel using its `setSelectionMode()` method. You can choose whether it should be possible to select only one row, or multiple rows, or even individual cells. Here is an example of setting the selection mode of a TableViewSelectionModel:

```
// set selection mode to only 1 row
selectionModel.setSelectionMode(SelectionMode.SINGLE);	// 默认方法

// set selection mode to multiple rows
selectionModel.setSelectionMode(SelectionMode.MULTIPLE);
```

### Get Selected Rows

To obtain a list of the selected row items of a JavaFX TableView, you call the SelectionModel `getSelectedItems()` method. The list returned is read-only. Here is an example of obtaining a list of the selected rows from a JavaFX TableView SelectionModel:

```java
ObservableList<Person> selectedItems = selectionModel.getSelectedItems();
```

### Get Selected Indices

You can also just obtain a list of the indices of the selected rows, instead of the selected items themselves. Here is an example of obtaining a list of the indices of selected rows from a TableViewSelectionModel:

```java
ObservableList<Integer> selectedIndices = selectionModel.getSelectedIndices();
```

### Clear Selection

```
selectionModel.clearSelection();
```

### Listening for Selection Changes

It is possible to listen for selection changes in the TableViewSelectionModel. To do so, you must attach a listener to one of the ObservableList's returned by either `getSelectedItems()` or `getSelectedIndices()`. Which of the two lists you should use depends on whether you need to obtain the selected items or selected indices when selection changes. Here is an example of attaching a change listener to the the ObservableList returned by `getSelectedItems()`:

```java
ObservableList<Person> selectedItems = selectionModel.getSelectedItems();

selectedItems.addListener(new ListChangeListener<Person>() {
  @Override
  public void onChanged(Change<? extends Person> change) {
    System.out.println("Selection changed: " + change.getList());
  }
}
```

### Select Rows Programmatically

可以在 javafxtableview 中以编程方式选择行。 您可以通过 TableViewSelectionModel 对象的许多选择方法来实现。 要选择具有特定索引的行，可以使用 select (int)方法。 下面是一个在 JavaFX TableView 中选择具有给定索引的单行的例子:

```
selectionModel.select(1);
```

此示例选择索引为1的行。请记住，行索引从0开始。

## Nested Columns

表视图时可以做嵌套的：

![image-20200504163357160](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504163357160.png)

代码如下：

```java
TableView tableView = new TableView();
    
TableColumn<String, Customer> customer   = new TableColumn<>("Customer");
TableColumn<String, Customer> customerId = new TableColumn<>("Customer No");
TableColumn<String, Customer> name       = new TableColumn<>("Name");
TableColumn<String, Customer> firstName  = new TableColumn<>("First Name");
TableColumn<String, Customer> lastName   = new TableColumn<>("Last Name");

name     .getColumns().addAll(firstName, lastName);
customer .getColumns().addAll(customerId, name);
tableView.getColumns().addAll(customer);

customerId.setCellValueFactory(new PropertyValueFactory<>("customerNo"));
firstName .setCellValueFactory(new PropertyValueFactory<>("firstName"));
lastName  .setCellValueFactory(new PropertyValueFactory<>("lastName"));

tableView.getItems().add(new Customer("007", "Jane", "Deer"));
tableView.getItems().add(new Customer("006", "John", "Doe"));
tableView.getItems().add(new Customer("008", "Mack", "Alamo"));
```

### Visible Leaf Columns

The JavaFX TableView class has a method called c which can return a visible leaf column (TableColumn) of the TableView. You pass the index of the visible leaf column to get as parameter to the `getVisibleLeafColumn()` method. Here is an example of obtaining the second (index 1) visible leaf column from a JavaFX TableView:

```java
TableColumn<String, Customer> leafColumn =
    tableView.getVisibleLeafColumn(1);
```

If the above code was executed against the TableView configured in the example in the previous section, the TableColumn returned would be the "First Name" TableColumn.

You can also obtain all visible leaf columns via the TableView `getVisibleLeafColumns()` .

## Hide Columns

Javafxtableview 可以通过调用传递 false 作为参数的 TableColumn setVisible ()来隐藏 TableColumn。 下面是一个隐藏 TableColumn 的例子:

```
tableColumn.setVisible(true);
```

第一种方法是将列拖动到 TableView 中不同的水平位置。 这是由最终用户完成的，而不是开发人员。

![image-20200504163847489](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504163847489.png)

第二种方法是更改 TableView getColumns ()方法返回的 ObservableList 中 TableColumn 实例的顺序。 这是通过编程完成的。 下面是一个删除第一列并将其添加为 TableView 的最后一列的例子:

```java
tableView.getColumns().add(
    tableView.getColumns().remove(0));
```

## Sorting Rows

第一种方法是让用户单击 TableColumn 标题单元格(显示列标题的单元格)。 这将对 TableView 中的行按照该列的值进行排序。 如果用户再次单击同一个 TableColumn 单元格，排序顺序将颠倒。 如果用户第三次单击，该列上的排序将再次被禁用。

对 TableView 的行进行排序的第二种方法是编程式的。 您可以设置排序顺序(升序或降序)、设置自定义的 Comparator 以比较 TableColumn 的值、设置要显示的自定义排序图标，甚至完全禁用给定 TableColumn 的排序。 下面将更详细地解释这些选项。

### Sort Type

您可以使用 TableColumn setSortType ()方法指定希望列使用的排序类型。 您可以将排序类型设置为升序或降序。 这里有两个例子说明如何设置这两种排序类型:

```
tableColumn.setSortType(TableColumn.SortType.ASCENDING);

tableColumn.setSortType(TableColumn.SortType.DESCENDING);
```

### Disable Sorting for a Column

```
tableColumn.setSortable(false);	
```

### Column Custom Comparator

自定义comparator就行了，然后通过：

```java
tableColumn.setComparator(columnComparator);
```

设置比较器。

Tablecolumn 上有一个默认的 Comparator 设置，它可以为您执行某种智能形式的默认排序。 有时，默认的比较器就足够了。 下面是默认的 Comparator 如何比较同一列中显示的两个值:

1. Checks for null values. A null value is considered less than a non-null value. If both values are null they are considered equal.
2. If the first value is an object implementing the Comparable interface, then the default Comparator will return value1.compareTo(value2) .
3. If rule 1 and 2 did not apply to the values - the default Comparator converts the two values into Strings using their .toString() methods, and compares these.

### Column Sort Node

Tablecolumn 类使用“ sort Node”来显示当前应用于该列的排序类型。 排序节点显示在列标题中。 默认的排序节点是一个箭头状的三角形。

您可以通过它的 setSortNode ()方法更改 TableColumn 的排序节点，并传递一个 JavaFX 节点作为排序节点使用。 下面是一个将 ImageView 设置为 TableColumn 上的排序节点的例子:

```java
FileInputStream input = new FileInputStream("images/sort-image.png");
Image image = new Image(input);
ImageView sortImage = new ImageView(image);

tableColumn.setSortNode(sortImage);
```

注意: 当排序类型从升序变为降序时，TableColumn 使用的默认排序节点旋转180度。 但是，对于自定义排序节点，似乎不会发生这种旋转。 当排序类型更改时，您可能必须自己管理排序节点的更改。

### Column Sort Order

使用 javafxtableview 可以指定 TableView 的默认排序顺序。 Tableview 中的项目将按此顺序排序——直到用户单击某些 TableColumn 头并更改排序顺序为止。

默认排序顺序由 TableColumn 实例的 ObservableList 组成。 Tableview 中的项将在此列表中第一个 TableColumn 上的排序集之后进行排序。 如果第一个 TableColumn 的值相等，则根据第二个 TableColumn 上的排序集对项进行排序，如果它们相等，则对第三个 TableColumn 进行排序。

下面是一个设置默认排序顺序的例子:

```
 tableView.getSortOrder().addAll(lastNameColumn, firstNameColumn);
```

### Trigger Sorting Manually

```
tableView.sort();
```

### Sort Events

```java
tableView.setOnSort((event) -> {
    System.out.println("Sorting items");
});
```

顺便说一下，如果事件侦听器调用 event.consume ()-那么排序将被取消。 下面是它的样子:

```java
tableView.setOnSort((event) -> {
    event.consume();
});
```

### Disable Sorting for TableView

您可以通过侦听排序事件并使用它们(调用 event.consume ())或禁用对所有 TableColumn 实例的排序来禁用整个 TableView 的排序。 还有其他方法可以禁用整个 TableView 的排序，但这两种方法应该足够了。

## Custom Cell Rendering

使用 javafxtableview 可以自定义 TableView 中显示的单元格的呈现。 添加到 TableView 的每个 TableColumn 在 TableView 中的每个可见行都有一个单元格。 这意味着，如果 TableView 有10个可见行和3个列，那么每个列(TableColumn)有10个单元格——总共有30个单元格。

如前所述，单元格计数由可见行和列(可见单元格)的数量决定。 Tableview 的项目列表中是否有1000个数据项(行)并不重要。 重要的是在给定的时间内有多少行可见。 可见单元格对象将被重用，以显示任何给定时间可见的行的值。 与为每一行的每一列(数据项)创建单元格对象相比，这种设计节省了大量单元格对象的创建。

若要自定义单元呈现，必须在要为其自定义单元呈现的 TableColumn 上设置单元工厂。 您可以通过 TableColumn setCellFactory ()方法设置一个 cell factory。 Setcellfactory ()方法以 Callback 接口实现作为参数。 Callback 实现创建 TableCell 实例。 每个 TableCell 实例对应于 TableView 中的一个可见单元格。 每个 TableCell 创建一次 Callback 实现，所以 Callback 实现不需要知道 TableView 中有多少可见单元格。

To better understand how cell factories work, let us look at an example of setting a cell factory on a TableColumn:

```java
customerColumn.setCellFactory((tableColumn) -> {
    TableCell<Customer, String> tableCell = new TableCell<>() {
        @Override
        protected void updateItem(String item, boolean empty) {
            super.updateItem(item, empty);

            this.setText(null);
            this.setGraphic(null);

            if(!empty){
                this.setText(item.toUpperCase());
            }
        }
    };

    return tableCell;
})
```

此示例使用 Callback 实现调用 setCellFactory ()方法，并将其作为 javalambda 表达式。

Callback 实现创建一个 TableCell 并返回它。 创建的 TableCell 是 TableCell 类的一个匿名子类，其中重写了 updateItem ()方法。 Tablecell 子类上的 updateItem ()方法在每次 TableCell 显示新项(行)的列值时被调用。 这就是为什么 updateItem ()方法首先调用 setText (null)和 setGraphic (null)来清除 TableCell 之前显示的任何文本和图形。

在清除前一项(行)中的值之后，将设置新值——如果单元格不为空，则为。 传递给 updateItem ()的第二个参数是一个布尔值，如果单元格为空，该值将为 true。 如果单元格为空，TableCell 不应该显示任何值。

Tablecell 类似于 javafxlabel ——这意味着它可以同时显示图形和文本。 要显示 TableCell updateItem ()的图形，可以使用 javafxnode 对象作为参数调用 setGraphic ()方法。 以 String 作为参数显示文本调用 setText ()。 Tablecell 可以同时显示图形和文本。

# TreeView

The JavaFX *TreeeView* enables you to display tree views inside your JavaFX applications. The JavaFX TreeView is represented by the class `javafx.scene.control.TreeView` .

![image-20200504170851076](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504170851076.png)

例子：

```java
public class TreeViewExample extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        TreeView treeView = new TreeView();
		
        // add items
        
        VBox vbox = new VBox(treeView);

        Scene scene = new Scene(vbox);

        primaryStage.setScene(scene);

        primaryStage.show();
    }

}
```

## Add Tree Items to TreeView

```java
TreeItem rootItem = new TreeItem("Tutorials");

TreeItem webItem = new TreeItem("Web Tutorials");
webItem.getChildren().add(new TreeItem("HTML  Tutorial"));
webItem.getChildren().add(new TreeItem("HTML5 Tutorial"));
webItem.getChildren().add(new TreeItem("CSS Tutorial"));
webItem.getChildren().add(new TreeItem("SVG Tutorial"));
rootItem.getChildren().add(webItem);

TreeItem javaItem = new TreeItem("Java Tutorials");
javaItem.getChildren().add(new TreeItem("Java Language"));
javaItem.getChildren().add(new TreeItem("Java Collections"));
javaItem.getChildren().add(new TreeItem("Java Concurrency"));
rootItem.getChildren().add(javaItem);

TreeView treeView = new TreeView();
treeView.setRoot(rootItem);
```

可以看到 TreeItem 可以将其他 TreeItem 实例作为子实例。 这种父子关系可以递归地、无限地继续下去。 这就是如何在 JavaFX 应用程序中逻辑地构造树节点的方法

## Hide Root Item of TreeView

您可以隐藏 javafxtreeview 的根项(根节点)。 为此，可以调用 setShowRoot ()方法，将布尔值 false 作为参数传递给它。 下面是一个隐藏 JavaFX 树视图的根树项目的例子:

![image-20200504171034389](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504171034389.png)

# TreeTableView

Javafxtreetableview 类是 javafxtreeview 和 javafxtableview 的组合。 总的来说，javafxtreetableview 是一个 TableView，其最左侧列包含一个项目树。 其余的列是普通的表列。

Javafxtreetableview 在其树中的每个条目上显示行。 换句话说，每个树节点右边显示的列属于左边树中的项。 Javafxtreetableview 最左侧列中的树项可以展开和折叠。 当树折叠或展开时，右边的row也会折叠或展开。

![image-20200504171816143](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504171816143.png)

## Create a TreeTableView

```
TreeTableView<Car> treeTableView = new TreeTableView<Car>();
```

```java
public class Car {

    private String brand = null;
    private String model = null;

    public Car() {
    }

    public Car(String brand, String model) {
        this.brand = brand;
        this.model = model;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }
}
```

对于在列中显示这些值的 TreeTableView，必须向 TreeTableView 添加一个或多个 TreeTableColumn 实例。 下面是在 JavaFX 树形视图中添加两个 TreeTableColumn 实例的一个例子:

```java
TreeTableView<Car> treeTableView = new TreeTableView<Car>();

TreeTableColumn<Car, String> treeTableColumn1 = new TreeTableColumn<>("Brand");
TreeTableColumn<Car, String> treeTableColumn2 = new TreeTableColumn<>("Model");

treeTableColumn1.setCellValueFactory(new TreeItemPropertyValueFactory<>("brand"));
treeTableColumn2.setCellValueFactory(new TreeItemPropertyValueFactory<>("model"));

treeTableView.getColumns().add(treeTableColumn1);
treeTableView.getColumns().add(treeTableColumn2);
```

## Add TreeItem to TreeTableView

要使 JavaFX TreeTableView 显示任何数据，必须向其添加一个或多个 TreeItem 实例。 下面是一个将9个 TreeItem 对象添加到 JavaFX TreeTableView 的例子:

```java
TreeItem mercedes1 = new TreeItem(new Car("Mercedes", "SL500"));
TreeItem mercedes2 = new TreeItem(new Car("Mercedes", "SL500 AMG"));
TreeItem mercedes3 = new TreeItem(new Car("Mercedes", "CLA 200"));

TreeItem mercedes = new TreeItem(new Car("Mercedes", "..."));
mercedes.getChildren().add(mercedes1);
mercedes.getChildren().add(mercedes2);

TreeItem audi1 = new TreeItem(new Car("Audi", "A1"));
TreeItem audi2 = new TreeItem(new Car("Audi", "A5"));
TreeItem audi3 = new TreeItem(new Car("Audi", "A7"));

TreeItem audi = new TreeItem(new Car("Audi", "..."));
audi.getChildren().add(audi1);
audi.getChildren().add(audi2);
audi.getChildren().add(audi3);

TreeItem cars = new TreeItem(new Car("Cars", "..."));
cars.getChildren().add(audi);
cars.getChildren().add(mercedes);

treeTableView.setRoot(cars);
```

# HTMLEditor 富文本编辑器

## Full HTMLEditor Example

```java
public class HtmlEditorExample extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    public void start(Stage primaryStage) {

        HTMLEditor htmlEditor = new HTMLEditor();

        VBox vBox = new VBox(htmlEditor);
        Scene scene = new Scene(vBox);

        primaryStage.setScene(scene);
        primaryStage.setTitle("JavaFX App");

        primaryStage.show();
    }
}
```

## Get HTML From HTMLEditor

```java
String htmlText = htmlEditor.getHtmlText();
```

## Set HTML in HTMLEditor

```java
String htmlText = "<b>Bold text</b>";

htmlEditor.setHtmlText(htmlText);
```

Javafx 分页控件使用户能够逐页浏览内容，例如搜索结果、文章、图片或类似类型的内容的页面。 Javafx 分页控件由类 JavaFX.scene.control 表示。 分页。 下面是一个 JavaFX 分页控件的截图:

## Full Pagination Example

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.Pagination;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.stage.Stage;

public class PaginationExample extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("JavaFX App");

        Pagination pagination = new Pagination();
        pagination.setPageCount(21);
        pagination.setCurrentPageIndex(3);
        pagination.setMaxPageIndicatorCount(3);

        pagination.setPageFactory((pageIndex) -> {

            Label label1 = new Label("Content for page with index: " + pageIndex);
            label1.setFont(new Font("Arial", 24));

            Label label2 = new Label("Main content of the page ...");

            return new VBox(label1, label2);
        });

        VBox vBox = new VBox(pagination);
        Scene scene = new Scene(vBox, 960, 600);

        primaryStage.setScene(scene);
        primaryStage.show();
    }
}
```

![image-20200504172726976](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504172726976.png)

The JavaFX `Pagination` control contains a set of properties that specify how the `Pagination` control is rendered. These properties are:

- Page count
- Current page index
- Max number of page indicators

这三个属性的效果都可以在本教程前面的截图中看到。 下面是一个设置所有三个属性的例子:

```
Pagination pagination = new Pagination();

pagination.setPageCount(21);
pagination.setCurrentPageIndex(3);
pagination.setMaxPageIndicatorCount(3);
```

## Pagination Page Factory

The JavaFX `Pagination` control needs a page factory set on it to be able to navigate properly through the paged content. The page factory is called when the user navigates to a new page. The page factory component is attached to the `Pagination` control via its `setPageFactory()` method, and must implement the interface `javafx.util.Callback` interface.

下面是 CallBack 接口的定义:

```
public interface Callback<P,R> {

    public R call(P param);

}
```

In the `setPageFactory()` method the two type parameters P and R are set to `Integer` (P) and `Node` (R). That means, that the page factory must implement the `Callback` interface. Here is an example of an implementation of `Callback`:

```java
public static class MyPageFactory implements Callback<Integer, Node> {
    @Override
    public Node call(Integer pageIndex) {
        return new Label("Content for page " + pageIndex);
    }
}
```

The `Integer` parameter passed to the `Callback` implementation is the index of the page the page factory should create a `Node` for. The returned `Node` should display the content for the page with the given page index.

Here is an example of setting the page factory on a JavaFX `Pagination` control:

```
pagination.setPageFactory(new MyPageFactory());
```

或者匿名内部类，或者lambda表达式，或者方法引用。

# BarChart

The JavaFX BarChart component is capable of drawing a bar chart inside your JavaFX applications. This is useful in dashboard-like applications. The JavaFX BarChart component is represented by the class `javafx.scene.chart.BarChart`

## BarChart X Axis and Y Axis

一个 JavaFX BarChart 绘制一个条形图。 柱状图是一个二维图形，意味着这个图形有一个 x 轴和一个 y 轴。 对于条形图，x 轴通常是某种类型的一个类别，而 y 轴是数字。

例如，想象一个条形图，显示桌面、手机和平板电脑用户访问一个网站的次数。 条形图显示三条线。 X 轴上的类别是“桌面”、“电话”和“平板”。 Y 轴将显示 x 轴上每个类别的访问次数，因此 y 轴是数字。

You need to define the X axis and Y axis used by a `BarChart`. A categorical axis is represented by the JavaFX class `javafx.scene.chart.CategoryAxis`. A numerical axis is represented by the JavaFX class `javafx.scene.chart.NumberAxis` .

Here is an example of creating a JavaFX `CategoryAxis` and `NumberAxis`:

```
CategoryAxis xAxis    = new CategoryAxis();
xAxis.setLabel("Devices");

NumberAxis yAxis = new NumberAxis();
yAxis.setLabel("Visits");
```

## Creating a BarChart

要创建 javafxbarchart 组件，必须创建 BarChart 类的实例。 必须将 x 轴和 y 轴实例传递给 BarChart 构造函数。 下面是 JavaFX BarChart 的实例化示例:

```java
CategoryAxis xAxis    = new CategoryAxis();
xAxis.setLabel("Devices");

NumberAxis yAxis = new NumberAxis();
yAxis.setLabel("Visits");

BarChart     barChart = new BarChart(xAxis, yAxis);
```

可以在同一条形图中显示多个数据序列。 我将在后面的 BarChart 教程中展示如何做到这一点。

## BarChart Data Series

为了让 javafxbarchart 组件显示任何条形图，必须向它提供一个数据序列。 数据系列是数据点的列表。 每个数据点包含一个 x 值和一个 y 值。 下面是一个创建数据系列并将其添加到 BarChart 组件的示例:

```
XYChart.Series dataSeries1 = new XYChart.Series();
dataSeries1.setName("2014");

dataSeries1.getData().add(new XYChart.Data("Desktop", 178));
dataSeries1.getData().add(new XYChart.Data("Phone"  , 65));
dataSeries1.getData().add(new XYChart.Data("Tablet"  , 23));


barChart.getData().add(dataSeries1);
```

First an `XYChart.Series` instance is created and given a name. Second,  `XYChart.Data` instances are added to the `XYChart.Series` object. Third, the `XYChart.Series` object is added to a `BarChart` object.

## Adding a BarChart to the Scene Graph

```java
public class BarChartExperiments extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle("BarChart Experiments");

        CategoryAxis xAxis    = new CategoryAxis();
        xAxis.setLabel("Devices");

        NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel("Visits");

        BarChart     barChart = new BarChart(xAxis, yAxis);

        XYChart.Series dataSeries1 = new XYChart.Series();
        dataSeries1.setName("2014");

        dataSeries1.getData().add(new XYChart.Data("Desktop", 567));
        dataSeries1.getData().add(new XYChart.Data("Phone"  , 65));
        dataSeries1.getData().add(new XYChart.Data("Tablet"  , 23));

        barChart.getData().add(dataSeries1);

        VBox vbox = new VBox(barChart);

        Scene scene = new Scene(vbox, 400, 200);

        primaryStage.setScene(scene);
        primaryStage.setHeight(300);
        primaryStage.setWidth(1200);

        primaryStage.show();
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}
```

![image-20200504173543265](https://pic.downk.cc/item/5eafe21bc2a9a83be5a1fca7.png)

## Displaying Multiple Data Series in the Same BarChart

As mentioned earlier in this tutorial it is possible to display multiple data series in the same `BarChart` component. You do so simply by adding multiple data series to the `BarChart` component.

When displaying multiple data series in the same `BarChart`, **the data points are categorized by their X values (category).** Thus, all data points across the different data series with the same X value will displayed next to each other in the bar chart. Here is first an example of creating two data series with data points that have the same X value (category):

```java
XYChart.Series dataSeries1 = new XYChart.Series();
dataSeries1.setName("2014");

dataSeries1.getData().add(new XYChart.Data("Desktop", 567));
dataSeries1.getData().add(new XYChart.Data("Phone"  , 65));
dataSeries1.getData().add(new XYChart.Data("Tablet"  , 23));

barChart.getData().add(dataSeries1);

XYChart.Series dataSeries2 = new XYChart.Series();
dataSeries2.setName("2015");

dataSeries2.getData().add(new XYChart.Data("Desktop", 540));
dataSeries2.getData().add(new XYChart.Data("Phone"  , 120));
dataSeries2.getData().add(new XYChart.Data("Tablet"  , 36));

barChart.getData().add(dataSeries2);
```

### 完整例子：

![image-20200504173854745](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504173854745.png)

按x类别排列。

# StackedBarChart

![image-20200504174302557](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504174302557.png)

## StackedBarChart X Axis and Y Axis

A JavaFX StackedBarChart draws a stacked bar chart. A stacked bar chart is a two-dimensional graph, meaning the graph has an X axis and a Y axis. For stacked bar charts the X axis is typically a category of some kind, and the Y axis is numerical.

例如，想象一个堆叠的条形图，显示2014年和2015年来自台式机、手机和平板电脑用户的网站访问量。 堆叠的条形图将显示2个条形。 一个栏是2014年来自台式电脑、手机和平板电脑的访问量，另一个栏是2015年的访问量。

X 轴上的类别是“桌面”、“电话”和“平板”。 Y 轴将显示 x 轴上每个类别的访问次数，因此 y 轴是数字。

You need to define the X axis and Y axis used by a `StackedBarChart`. A categorical axis is represented by the JavaFX class `javafx.scene.chart.CategoryAxis`. A numerical axis is represented by the JavaFX class `javafx.scene.chart.NumberAxis` .

## StackedBarChart Data Series

```java
StackedBarChart     stackedBarChart = new StackedBarChart(xAxis, yAxis);

XYChart.Series dataSeries1 = new XYChart.Series();
dataSeries1.setName("Desktop");

dataSeries1.getData().add(new XYChart.Data("2014", 567));
dataSeries1.getData().add(new XYChart.Data("2015", 540));

stackedBarChart.getData().add(dataSeries1);

XYChart.Series dataSeries2 = new XYChart.Series();
dataSeries2.setName("Phone");

dataSeries2.getData().add(new XYChart.Data("2014"  , 65));
dataSeries2.getData().add(new XYChart.Data("2015"  , 120));

stackedBarChart.getData().add(dataSeries2);

XYChart.Series dataSeries3 = new XYChart.Series();
dataSeries3.setName("Tablet");

dataSeries3.getData().add(new XYChart.Data("2014"  , 23));
dataSeries3.getData().add(new XYChart.Data("2015"  , 36));

stackedBarChart.getData().add(dataSeries3);
```

## 完整例子

```java
@Override
public void start(Stage primaryStage) throws Exception {
    primaryStage.setTitle("StackedBarChart Experiments");

    CategoryAxis xAxis    = new CategoryAxis();
    xAxis.setLabel("Devices");
    xAxis.getCategories().addAll("Desktop", "Phone", "Tablet");

    NumberAxis yAxis = new NumberAxis();
    yAxis.setLabel("Visits");

    StackedBarChart     stackedBarChart = new StackedBarChart(xAxis, yAxis);

    XYChart.Series dataSeries1 = new XYChart.Series();
    dataSeries1.setName("Desktop");

    dataSeries1.getData().add(new XYChart.Data("2014", 567));
    dataSeries1.getData().add(new XYChart.Data("2015", 540));

    stackedBarChart.getData().add(dataSeries1);

    XYChart.Series dataSeries2 = new XYChart.Series();
    dataSeries2.setName("Phone");

    dataSeries2.getData().add(new XYChart.Data("2014"  , 65));
    dataSeries2.getData().add(new XYChart.Data("2015"  , 120));

    stackedBarChart.getData().add(dataSeries2);

    XYChart.Series dataSeries3 = new XYChart.Series();
    dataSeries3.setName("Tablet");

    dataSeries3.getData().add(new XYChart.Data("2014"  , 23));
    dataSeries3.getData().add(new XYChart.Data("2015"  , 36));

    stackedBarChart.getData().add(dataSeries3);

    VBox vbox = new VBox(stackedBarChart);

    Scene scene = new Scene(vbox, 400, 200);

    primaryStage.setScene(scene);
    primaryStage.setHeight(300);
    primaryStage.setWidth(1200);

    primaryStage.show();
}
```

![image-20200504174548309](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504174548309.png)

# ScatterChart

The JavaFX ScatterChart component can draw scatter charts inside your JavaFX applications. The JavaFX ScatterChart component is represented by the class `javafx.scene.chart.ScatterChart`.

![image-20200504174800806](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504174800806.png)

## 完整例子

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.ScatterChart;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class ScatterChartExperiments extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle("BarChart Experiments");

        NumberAxis xAxis = new NumberAxis();
        xAxis.setLabel("No of employees");

        NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel("Revenue per employee");

        ScatterChart scatterChart = new ScatterChart(xAxis, yAxis);

        XYChart.Series dataSeries1 = new XYChart.Series();
        dataSeries1.setName("2014");

        dataSeries1.getData().add(new XYChart.Data( 1, 567));
        dataSeries1.getData().add(new XYChart.Data( 5, 612));
        dataSeries1.getData().add(new XYChart.Data(10, 800));
        dataSeries1.getData().add(new XYChart.Data(20, 780));
        dataSeries1.getData().add(new XYChart.Data(40, 810));
        dataSeries1.getData().add(new XYChart.Data(80, 850));

        scatterChart.getData().add(dataSeries1);

        VBox vbox = new VBox(scatterChart);

        Scene scene = new Scene(vbox, 400, 200);

        primaryStage.setScene(scene);
        primaryStage.setHeight(300);
        primaryStage.setWidth(1200);

        primaryStage.show();
    }


    public static void main(String[] args) {
        Application.launch(args);
    }
}
```

# LineChart

The JavaFX LineChart can draw line charts inside your JavaFX applications. The JavaFX LineChart component is represented by the class `javafx.scene.chart.LineChart` .

## 完整例子

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class LineChartExperiments extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle("LineChart Experiments");

        NumberAxis xAxis = new NumberAxis();
        xAxis.setLabel("No of employees");

        NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel("Revenue per employee");

        LineChart lineChart = new LineChart(xAxis, yAxis);

        XYChart.Series dataSeries1 = new XYChart.Series();
        dataSeries1.setName("2014");

        dataSeries1.getData().add(new XYChart.Data( 1, 567));
        dataSeries1.getData().add(new XYChart.Data( 5, 612));
        dataSeries1.getData().add(new XYChart.Data(10, 800));
        dataSeries1.getData().add(new XYChart.Data(20, 780));
        dataSeries1.getData().add(new XYChart.Data(40, 810));
        dataSeries1.getData().add(new XYChart.Data(80, 850));

        lineChart.getData().add(dataSeries1);

        VBox vbox = new VBox(lineChart);

        Scene scene = new Scene(vbox, 400, 200);

        primaryStage.setScene(scene);
        primaryStage.setHeight(300);
        primaryStage.setWidth(1200);

        primaryStage.show();
    }


    public static void main(String[] args) {
        Application.launch(args);
    }
}
```

![image-20200504175022273](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504175022273.png)

# AreaChart

## 完整例子

```java
@Override
public void start(Stage primaryStage) throws Exception {
    primaryStage.setTitle("AreaChart Experiments");

    NumberAxis xAxis = new NumberAxis();
    xAxis.setLabel("No of employees");

    NumberAxis yAxis = new NumberAxis();
    yAxis.setLabel("Revenue per employee");

    AreaChart areaChart = new AreaChart(xAxis, yAxis);

    XYChart.Series dataSeries1 = new XYChart.Series();
    dataSeries1.setName("2014");

    dataSeries1.getData().add(new XYChart.Data( 1, 567));
    dataSeries1.getData().add(new XYChart.Data( 5, 612));
    dataSeries1.getData().add(new XYChart.Data(10, 800));
    dataSeries1.getData().add(new XYChart.Data(20, 780));
    dataSeries1.getData().add(new XYChart.Data(40, 810));
    dataSeries1.getData().add(new XYChart.Data(80, 850));

    areaChart.getData().add(dataSeries1);

    VBox vbox = new VBox(areaChart);

    Scene scene = new Scene(vbox, 400, 200);

    primaryStage.setScene(scene);
    primaryStage.setHeight(300);
    primaryStage.setWidth(1200);

    primaryStage.show();
}
```

![image-20200504175236424](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504175236424.png)

# StackedAreaChart

一个 javafxstakedareachart 组件能够在 JavaFX 应用程序中绘制堆叠区域图。 堆积面积图类似于具有多个数据序列的面积图，只是堆积面积图显示的数据序列(因此区域)相互叠加，其中正常面积图将它们重叠。

### 完整例子：

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.StackedAreaChart;
import javafx.scene.chart.XYChart;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class StackedAreaChartExperiments extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle("StackedAreaChart Experiments");

        NumberAxis xAxis = new NumberAxis();
        xAxis.setLabel("7 Day Interval");

        NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel("Visits");

        StackedAreaChart stackedAreaChart = new StackedAreaChart(xAxis, yAxis);

        XYChart.Series dataSeries1 = new XYChart.Series();
        dataSeries1.setName("Desktop");

        dataSeries1.getData().add(new XYChart.Data( 0, 567));
        dataSeries1.getData().add(new XYChart.Data( 1, 612));
        dataSeries1.getData().add(new XYChart.Data( 2, 800));
        dataSeries1.getData().add(new XYChart.Data( 3, 780));
        dataSeries1.getData().add(new XYChart.Data( 4, 650));
        dataSeries1.getData().add(new XYChart.Data( 5, 610));
        dataSeries1.getData().add(new XYChart.Data( 6, 590));

        stackedAreaChart.getData().add(dataSeries1);

        XYChart.Series dataSeries2 = new XYChart.Series();
        dataSeries2.setName("Mobile");

        dataSeries2.getData().add(new XYChart.Data( 0, 101));
        dataSeries2.getData().add(new XYChart.Data( 1, 110));
        dataSeries2.getData().add(new XYChart.Data( 2, 140));
        dataSeries2.getData().add(new XYChart.Data( 3, 132));
        dataSeries2.getData().add(new XYChart.Data( 4, 115));
        dataSeries2.getData().add(new XYChart.Data( 5, 109));
        dataSeries2.getData().add(new XYChart.Data( 6, 105));

        stackedAreaChart.getData().add(dataSeries2);

        VBox vbox = new VBox(stackedAreaChart);

        Scene scene = new Scene(vbox, 400, 200);

        primaryStage.setScene(scene);
        primaryStage.setHeight(300);
        primaryStage.setWidth(1200);

        primaryStage.show();
    }


    public static void main(String[] args) {
        Application.launch(args);
    }
}
```

![image-20200504175457959](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200504175457959.png)